{"compiler":{"version":"0.8.28+commit.7893614a"},"language":"Solidity","output":{"abi":[{"inputs":[],"name":"EnumerableRolesUnauthorized","type":"error"},{"inputs":[],"name":"InvalidRole","type":"error"},{"inputs":[],"name":"RoleHolderIsZeroAddress","type":"error"},{"inputs":[],"name":"RoleHoldersIndexOutOfBounds","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"holder","type":"address"},{"indexed":true,"internalType":"uint256","name":"role","type":"uint256"},{"indexed":true,"internalType":"bool","name":"active","type":"bool"}],"name":"RoleSet","type":"event"},{"inputs":[{"internalType":"address","name":"holder","type":"address"},{"internalType":"uint256","name":"role","type":"uint256"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"result","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"role","type":"uint256"},{"internalType":"uint256","name":"i","type":"uint256"}],"name":"roleHolderAt","outputs":[{"internalType":"address","name":"result","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"role","type":"uint256"}],"name":"roleHolderCount","outputs":[{"internalType":"uint256","name":"result","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"role","type":"uint256"}],"name":"roleHolders","outputs":[{"internalType":"address[]","name":"result","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"holder","type":"address"},{"internalType":"uint256","name":"role","type":"uint256"},{"internalType":"bool","name":"active","type":"bool"}],"name":"setRole","outputs":[],"stateMutability":"payable","type":"function"}],"devdoc":{"author":"Solady (https://github.com/vectorized/solady/blob/main/src/auth/EnumerableRoles.sol)","details":"Note: This implementation is agnostic to the Ownable that the contract inherits from. It performs a self-staticcall to the `owner()` function to determine the owner. This is useful for situations where the contract inherits from OpenZeppelin's Ownable, such as in LayerZero's OApp contracts. This implementation performs a self-staticcall to `MAX_ROLE()` to determine the maximum role that can be set/unset. If the inheriting contract does not have `MAX_ROLE()`, then any role can be set/unset. This implementation allows for any uint256 role, it does NOT take in a bitmask of roles. This is to accommodate teams that are allergic to bitwise flags. By default, the `owner()` is the only account that is authorized to set roles. This behavior can be changed via overrides. This implementation is compatible with any Ownable. This implementation is NOT compatible with OwnableRoles.","errors":{"EnumerableRolesUnauthorized()":[{"details":"Unauthorized to perform the action."}],"InvalidRole()":[{"details":"The role has exceeded the maximum role."}],"RoleHolderIsZeroAddress()":[{"details":"Cannot set the role of the zero address."}],"RoleHoldersIndexOutOfBounds()":[{"details":"The index is out of bounds of the role holders array."}]},"events":{"RoleSet(address,uint256,bool)":{"details":"The status of `role` for `holder` has been set to `active`."}},"kind":"dev","methods":{"hasRole(address,uint256)":{"details":"Returns if `holder` has active `role`."},"roleHolderAt(uint256,uint256)":{"details":"Returns the holder of `role` at the index `i`."},"roleHolderCount(uint256)":{"details":"Returns the total number of holders of `role`."},"roleHolders(uint256)":{"details":"Returns an array of the holders of `role`."},"setRole(address,uint256,bool)":{"details":"Sets the status of `role` of `holder` to `active`."}},"stateVariables":{"_ENUMERABLE_ROLES_SLOT_SEED":{"details":"The storage layout of the holders enumerable mapping is given by: ```     mstore(0x18, holder)     mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)     mstore(0x00, role)     let rootSlot := keccak256(0x00, 0x24)     let positionSlot := keccak256(0x00, 0x38)     let holderSlot := add(rootSlot, sload(positionSlot))     let holderInStorage := shr(96, sload(holderSlot))     let length := shr(160, shl(160, sload(rootSlot))) ```"},"_ROLE_SET_EVENT_SIGNATURE":{"details":"`keccak256(bytes(\"RoleSet(address,uint256,bool)\"))`."}},"version":1},"userdoc":{"kind":"user","methods":{},"notice":"Enumerable multiroles authorization mixin.","version":1}},"settings":{"compilationTarget":{"solady/src/auth/EnumerableRoles.sol":"EnumerableRoles"},"evmVersion":"cancun","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":false,"runs":200},"remappings":[]},"sources":{"solady/src/auth/EnumerableRoles.sol":{"keccak256":"0xd7eafcc4adc2551bb5856591b1353a970265e120c9f0ef2b4670cb689966d7f6","license":"MIT","urls":["bzz-raw://00d41a196f7b709658eb7b4d3966e4bf18150301912b0250619e38e05e464b6a","dweb:/ipfs/QmadqqE45L22bCbZaUxvg5DtfwwHguYUQ4nD3ZtgrKMGWN"]}},"version":1}